/*
 * generated by Xtext 2.20.0
 */
package de.sebinside.dcp.dsl.generator

import de.sebinside.dcp.dsl.dSL.CharacteristicClass
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.palladiosimulator.supporting.prolog.model.prolog.Clause
import org.palladiosimulator.supporting.prolog.model.prolog.PrologFactory

import static de.sebinside.dcp.dsl.generator.DSLGeneratorUtils.*

class DSLGenerator extends AbstractGenerator {

	static final String DEV_OUTPUT_FILE_NAME = "output.pl"

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = PrologFactory.eINSTANCE.createProgram

		// Just testing with only Characteristic Classes
		for (element : resource.allContents.toIterable.filter(CharacteristicClass)) {
			program.clauses.addAll(element.compile)
		}

		// TODO
		saveFile(fsa, resource, program, DEV_OUTPUT_FILE_NAME)
	}

	def List<Clause> compile(CharacteristicClass charateristicClass) {
		val clauses = new ArrayList<Clause>

		// Create rule referencing all facts
		val rule = Rule('''CharacteristicClass_«charateristicClass.name»''')
		rule.body = null

		// A rules arguments are all contained member types
		rule.head.arguments.addAll(charateristicClass.members.map[member|member.ref.name].toSet.map [ type |
			CompoundTerm(type)
		].toList)

		// Create single facts for every member
		charateristicClass.members.forEach [ member, index |
			member.literals.forEach [ literal |

				// Create and add fact
				val factName = '''CharacteristicsClass_«charateristicClass.name»_«member.ref.name»_«index»«if(member.negated) "_NEG"»'''
				val fact = SimpleFact(factName, literal)
				clauses.add(fact)

				// Create fact reference for the rule
				val factReference = CompoundTerm(fact.head.value, CompoundTerm(member.ref.name))

				// Handle negated facts
				val factExpression = if (member.negated) {
						NotProvable(factReference)
					} else {
						factReference
					}

				// A rule body consists of one or multiple combined facts
				if (rule.body === null) {
					rule.body = factExpression
				} else {
					// FIXME: conjuncted is not supported yet
					rule.body = LogicalAnd(rule.body, factExpression)
				}
			]
		]

		clauses.add(rule)
		clauses
	}
}
