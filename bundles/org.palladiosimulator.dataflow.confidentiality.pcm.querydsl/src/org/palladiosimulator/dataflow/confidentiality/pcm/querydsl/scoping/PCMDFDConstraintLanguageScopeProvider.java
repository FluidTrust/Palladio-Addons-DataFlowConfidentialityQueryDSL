/*
 * generated by Xtext 2.24.0
 */
package org.palladiosimulator.dataflow.confidentiality.pcm.querydsl.scoping;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.FilteringScope;
import org.eclipse.xtext.scoping.impl.ImportNormalizer;
import org.eclipse.xtext.scoping.impl.ImportScope;
import org.palladiosimulator.dataflow.confidentiality.pcm.querydsl.pCMDFDConstraintLanguage.ActionNodeIdentitySelector;
import org.palladiosimulator.dataflow.confidentiality.pcm.querydsl.pCMDFDConstraintLanguage.DataChannelNodeIdentitySelector;
import org.palladiosimulator.dataflow.confidentiality.pcm.querydsl.pCMDFDConstraintLanguage.PCMDFDConstraintLanguagePackage;
import org.palladiosimulator.dataflow.confidentiality.pcm.querydsl.pCMDFDConstraintLanguage.SEFFNodeIdentitySelector;
import org.palladiosimulator.dataflow.confidentiality.pcm.querydsl.pCMDFDConstraintLanguage.StoreNodeIdentitySelector;
import org.palladiosimulator.dataflow.confidentiality.pcm.queryutils.ModelQueryUtils;
import org.palladiosimulator.dataflow.dictionary.characterized.DataDictionaryCharacterized.CharacteristicType;
import org.palladiosimulator.dataflow.dictionary.characterized.DataDictionaryCharacterized.EnumCharacteristicType;
import org.palladiosimulator.dataflow.dictionary.characterized.DataDictionaryCharacterized.Enumeration;
import org.palladiosimulator.dataflow.dictionary.characterized.DataDictionaryCharacterized.Literal;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.core.composition.CompositionPackage;
import org.palladiosimulator.pcm.core.entity.Entity;
import org.palladiosimulator.pcm.repository.BasicComponent;
import org.palladiosimulator.pcm.repository.OperationInterface;
import org.palladiosimulator.pcm.repository.OperationProvidedRole;
import org.palladiosimulator.pcm.repository.OperationSignature;
import org.palladiosimulator.pcm.repository.RepositoryPackage;
import org.palladiosimulator.pcm.seff.AbstractAction;
import org.palladiosimulator.pcm.seff.ResourceDemandingSEFF;
import org.palladiosimulator.pcm.seff.SeffPackage;
import org.palladiosimulator.pcm.seff.ServiceEffectSpecification;

import de.sebinside.dcp.dsl.dSL.CharacteristicTypeSelector;
import de.sebinside.dcp.dsl.dSL.DSLPackage;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping on how and when
 * to use it.
 */
public class PCMDFDConstraintLanguageScopeProvider extends AbstractPCMDFDConstraintLanguageScopeProvider {

    protected static ModelQueryUtils queryUtils = new ModelQueryUtils();

    @Override
    public IScope getScope(EObject context, EReference reference) {

        if (context instanceof CharacteristicTypeSelector
                && reference == DSLPackage.Literals.CHARACTERISTIC_TYPE_SELECTOR__LITERALS) {
            return getLiteralsScope(context, reference);
        }

        if (context instanceof StoreNodeIdentitySelector
                && reference == PCMDFDConstraintLanguagePackage.Literals.STORE_NODE_IDENTITY_SELECTOR__ASSEMBLIES) {
            return getAssemblyContextHierarchyScope(context, reference);
        }

        if (context instanceof SEFFNodeIdentitySelector) {
            var selector = (SEFFNodeIdentitySelector) context;
            var assembliesReference = PCMDFDConstraintLanguagePackage.Literals.SEFF_NODE_IDENTITY_SELECTOR__ASSEMBLIES;
            if (reference == assembliesReference) {
                return getAssemblyContextHierarchyScope(selector, reference);
            }
            if (reference == PCMDFDConstraintLanguagePackage.Literals.SEFF_NODE_IDENTITY_SELECTOR__SIGNATURE) {
                return getProvidedSignaturesForAssemblies(selector, reference, assembliesReference);
            }
        }

        if (context instanceof DataChannelNodeIdentitySelector
                && reference == PCMDFDConstraintLanguagePackage.Literals.DATA_CHANNEL_NODE_IDENTITY_SELECTOR__ASSEMBLIES) {
            return getAssemblyContextHierarchyScope(context, reference);
        }

        if (context instanceof ActionNodeIdentitySelector) {
            var selector = (ActionNodeIdentitySelector) context;
            var assembliesReference = PCMDFDConstraintLanguagePackage.Literals.ACTION_NODE_IDENTITY_SELECTOR__ASSEMBLIES;
            if (reference == assembliesReference) {
                return getAssemblyContextHierarchyScope(selector, reference);
            }
            if (reference == PCMDFDConstraintLanguagePackage.Literals.ACTION_NODE_IDENTITY_SELECTOR__SIGNATURE) {
                return getProvidedSignaturesForAssemblies(selector, reference, assembliesReference);
            }
            if (reference == PCMDFDConstraintLanguagePackage.Literals.ACTION_NODE_IDENTITY_SELECTOR__ACTION) {
                return getAction(selector, reference, assembliesReference);
            }
        }

        return super.getScope(context, reference);
    }

    protected IScope getAction(ActionNodeIdentitySelector selector, EReference reference,
            EReference assembliesReference) {
        var assemblies = findResolvedAssemblyContexts(selector, assembliesReference);
        if (assemblies.isEmpty()) {
            return IScope.NULLSCOPE;
        }
        var component = assemblies.get(assemblies.size() - 1)
            .getEncapsulatedComponent__AssemblyContext();
        if (!(component instanceof BasicComponent)) {
            return IScope.NULLSCOPE;
        }
        var basicComponent = (BasicComponent) component;

        var signature = selector.getSignature();
        if (signature == null || signature.eIsProxy()) {
            return IScope.NULLSCOPE;
        }

        var foundSeff = basicComponent.getServiceEffectSpecifications__BasicComponent()
            .stream()
            .filter(ResourceDemandingSEFF.class::isInstance)
            .map(ResourceDemandingSEFF.class::cast)
            .filter(s -> s.getDescribedService__SEFF()
                .equals(signature))
            .findFirst();
        if (foundSeff.isEmpty()) {
            return IScope.NULLSCOPE;
        }
        var seff = foundSeff.get();

        var seffActions = queryUtils.findAllChildrenIncludingSelfOfType(seff, AbstractAction.class);
        var seffActionSet = new HashSet<AbstractAction>();
        seffActions.forEach(seffActionSet::add);

        var superScope = super.getScope(selector, reference);
        var importNormalizer = new ImportNormalizer(QualifiedName.create(seff.getId()), true, false);
        var importScope = new ImportScope(Arrays.asList(importNormalizer), superScope, null,
                SeffPackage.Literals.ABSTRACT_ACTION, false);
        return new FilteringScope(importScope, description -> seffActionSet.contains(description.getEObjectOrProxy()));
    }

    protected IScope getLiteralsScope(EObject context, EReference reference) {
        CharacteristicType type = ((CharacteristicTypeSelector) context).getRef()
            .getRef();

        // Assumption: The DSL is intended to only work with EnumCharacteristicType
        if (type instanceof EnumCharacteristicType) {
            EnumCharacteristicType enumType = (EnumCharacteristicType) type;
            Enumeration literalEnumeration = enumType.getType();

            // This is the case if the characteristic type is invalid referenced
            if (literalEnumeration != null) {
                List<Literal> literals = literalEnumeration.getLiterals();

                IScope scope = Scopes.scopeFor(literals, literal -> QualifiedName.create(literal.getName()),
                        IScope.NULLSCOPE);

                return scope;
            }
        }
        return super.getScope(context, reference);
    }

    protected IScope getProvidedSignaturesForAssemblies(EObject context, EReference reference,
            EReference assembliesReference) {
        var superScope = super.getScope(context, reference);
        var assemblies = findResolvedAssemblyContexts(context, assembliesReference);
        if (assemblies.isEmpty()) {
            return superScope;
        }

        var lastAssembly = assemblies.get(assemblies.size() - 1);
        var encapsulatedComponent = lastAssembly.getEncapsulatedComponent__AssemblyContext();
        if (!(encapsulatedComponent instanceof BasicComponent)) {
            return IScope.NULLSCOPE;
        }

        var basicComponent = (BasicComponent) encapsulatedComponent;

        var signatureNameNormalizers = basicComponent.getProvidedRoles_InterfaceProvidingEntity()
            .stream()
            .filter(OperationProvidedRole.class::isInstance)
            .map(OperationProvidedRole.class::cast)
            .map(OperationProvidedRole::getProvidedInterface__OperationProvidedRole)
            .map(OperationInterface::getEntityName)
            .map(QualifiedName::create)
            .map(name -> new ImportNormalizer(name, true, false))
            .collect(Collectors.toList());
        var interfaceImportingScope = new ImportScope(signatureNameNormalizers, superScope, null,
                RepositoryPackage.Literals.OPERATION_SIGNATURE, false);

        var seffs = ((BasicComponent) encapsulatedComponent).getServiceEffectSpecifications__BasicComponent();
        var signatureCandidates = seffs.stream()
            .map(ServiceEffectSpecification::getDescribedService__SEFF)
            .filter(OperationSignature.class::isInstance)
            .map(OperationSignature.class::cast)
            .collect(Collectors.toList());
        return new FilteringScope(interfaceImportingScope, d -> signatureCandidates.contains(d.getEObjectOrProxy()));
    }

    protected IScope getAssemblyContextHierarchyScope(EObject selector, EReference reference) {
        var superScope = super.getScope(selector, reference);
        var resolvedAssemblies = findResolvedAssemblyContexts(selector, reference);
        var assemblyNames = resolvedAssemblies.stream()
            .map(Entity::getEntityName)
            .collect(Collectors.toList());
        if (assemblyNames.isEmpty()) {
            return superScope;
        }
        var importedName = QualifiedName.create(assemblyNames);
        var normalizerList = Arrays.asList(new ImportNormalizer(importedName, true, false));
        return new ImportScope(normalizerList, superScope, null, CompositionPackage.Literals.ASSEMBLY_CONTEXT, false);
    }

    protected List<AssemblyContext> findResolvedAssemblyContexts(EObject context, EReference assemblyListReference) {
        var referenceValue = context.eGet(assemblyListReference, false);
        if (!(referenceValue instanceof InternalEList<?>)) {
            throw new IllegalArgumentException(
                    "The list containing the assembly contexts is not of the expected type.");
        }
        // we need the InternalEList because we have to iterate over the contents of the list
        // without triggering the resolution of the list contents
        @SuppressWarnings("unchecked")
        var assemblyList = (InternalEList<AssemblyContext>) referenceValue;
        var resolvedAssemblies = new ArrayList<AssemblyContext>();
        for (var assemblyIter = assemblyList.basicListIterator(); assemblyIter.hasNext();) {
            var assembly = assemblyIter.next();
            if (assembly.eIsProxy()) {
                break;
            }
            resolvedAssemblies.add(assembly);
        }
        return resolvedAssemblies;
    }
}
